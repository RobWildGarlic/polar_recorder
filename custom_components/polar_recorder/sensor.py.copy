from __future__ import annotations
from homeassistant.components.sensor import SensorEntity, SensorStateClass
from homeassistant.const import EntityCategory, PERCENTAGE
from homeassistant.core import HomeAssistant
from homeassistant.config_entries import ConfigEntry
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from homeassistant.helpers.event import async_track_state_change_event

from .const import (
    CONF_TWA, CONF_TWS, CONF_BSP,
    CONF_TWA_MIN, CONF_TWA_MAX, CONF_TWA_STEP,
    CONF_TWS_MIN, CONF_TWS_MAX, CONF_TWS_STEP,
    CONF_FOLD_0_180, CONF_INTERPOLATE,
)
from .coordinator import PolarCoordinator

async def async_setup_entry(
    hass: HomeAssistant, entry: ConfigEntry, async_add_entities: AddEntitiesCallback
) -> None:
    coord: PolarCoordinator = entry.runtime_data
    async_add_entities(
        [
            PolarMatrixEntity(entry.entry_id, coord),
            PolarTargetSpeedEntity(entry.entry_id, coord),
            PolarPerformanceEntity(entry.entry_id, coord),   # NEW
        ],
        True,
    )

class _BaseEntity(SensorEntity):
    _attr_should_poll = False

    def __init__(self, unique_prefix: str, coord: PolarCoordinator) -> None:
        self._coord = coord
        self._attr_unique_id = f"{unique_prefix}-{self._suffix()}"

    def _suffix(self) -> str:
        raise NotImplementedError

    async def async_added_to_hass(self) -> None:
        # Refresh on matrix changes (coordinator notifies subscribers)
        self._coord.register(self.async_write_ha_state)

    # small helper
    def _state_float(self, entity_id: str):
        st = self.hass.states.get(entity_id)
        if not st:
            return None
        try:
            return float(st.state)
        except (TypeError, ValueError):
            return None

class PolarMatrixEntity(_BaseEntity):
    _attr_has_entity_name = True
    _attr_name = "Polar Matrix"
    _attr_icon = "mdi:sail-boat"
    _attr_entity_category = EntityCategory.DIAGNOSTIC

    def _suffix(self) -> str:
        return "polar-matrix"

    @property
    def native_value(self):
        # keep state tiny: last update timestamp
        return int(self._coord.last_update_ts or 0)

    @property
    def extra_state_attributes(self):
        cfg = self._coord.cfg
        return {
            "recording": self._coord.recording_enabled,
            "matrix": self._coord.matrix,                 # LARGE attr
            "twa_min": cfg[CONF_TWA_MIN],
            "twa_max": cfg[CONF_TWA_MAX],
            "twa_step": cfg[CONF_TWA_STEP],
            "tws_min": cfg[CONF_TWS_MIN],
            "tws_max": cfg[CONF_TWS_MAX],
            "tws_step": cfg[CONF_TWS_STEP],
            "fold_to_180": cfg.get(CONF_FOLD_0_180, True),
            "interpolate": cfg.get(CONF_INTERPOLATE, False),
            "csv": self._coord.build_csv(),               # copy/paste into Excel
        }

class PolarTargetSpeedEntity(_BaseEntity):
    _attr_has_entity_name = True
    _attr_name = "Polar Target Speed"
    _attr_icon = "mdi:speedometer"
    _attr_state_class = SensorStateClass.MEASUREMENT

    def _suffix(self) -> str:
        return "polar-target"

    async def async_added_to_hass(self) -> None:
        await super().async_added_to_hass()
        cfg = self._coord.cfg
        # Update when wind changes
        self._unsubs = [
            async_track_state_change_event(self.hass, [cfg[CONF_TWA]], self._on_src),
            async_track_state_change_event(self.hass, [cfg[CONF_TWS]], self._on_src),
        ]

    async def async_will_remove_from_hass(self) -> None:
        for u in getattr(self, "_unsubs", []):
            u()
        self._unsubs = []

    async def _on_src(self, _event) -> None:
        self.async_write_ha_state()

    @property
    def native_value(self):
        return self._compute_target()

    def _compute_target(self):
        cfg = self._coord.cfg
        twa = self._state_float(cfg[CONF_TWA])
        tws = self._state_float(cfg[CONF_TWS])
        if twa is None or tws is None:
            return None
        if cfg.get(CONF_FOLD_0_180, True):
            twa = self._coord._fold_0_180(twa)

        # guard ranges
        if not (cfg[CONF_TWA_MIN] <= twa <= cfg[CONF_TWA_MAX]) or not (cfg[CONF_TWS_MIN] <= tws <= cfg[CONF_TWS_MAX]):
            return None

        a_step, s_step = cfg[CONF_TWA_STEP], cfg[CONF_TWS_STEP]
        a0 = int(self._coord._bin_floor(twa, a_step, cfg[CONF_TWA_MIN], cfg[CONF_TWA_MAX]))
        s0 = int(self._coord._bin_floor(tws, s_step, cfg[CONF_TWS_MIN], cfg[CONF_TWS_MAX]))
        a1 = min(a0 + a_step, cfg[CONF_TWA_MAX])
        s1 = min(s0 + s_step, cfg[CONF_TWS_MAX])

        m = self._coord.matrix
        if not cfg.get(CONF_INTERPOLATE, False) or a1 == a0 or s1 == s0:
            return self._nearest(m, twa, tws, a0, a1, s0, s1, a_step, s_step)

        bk_a0 = self._coord._bin_key(a0, a_step)
        bk_a1 = self._coord._bin_key(a1, a_step)
        bk_s0 = self._coord._bin_key(s0, s_step)
        bk_s1 = self._coord._bin_key(s1, s_step)
        v00 = m.get(f"{bk_a0}|{bk_s0}")
        v10 = m.get(f"{bk_a1}|{bk_s0}")
        v01 = m.get(f"{bk_a0}|{bk_s1}")
        v11 = m.get(f"{bk_a1}|{bk_s1}")
        if None in (v00, v10, v01, v11):
            return self._nearest(m, twa, tws, a0, a1, s0, s1, a_step, s_step)

        ax = 0 if a1 == a0 else (twa - a0) / (a1 - a0)
        sx = 0 if s1 == s0 else (tws - s0) / (s1 - s0)
        v0 = v00 * (1 - ax) + v10 * ax
        v1 = v01 * (1 - ax) + v11 * ax
        return round(v0 * (1 - sx) + v1 * sx, 2)

def _nearest(self, m, twa, tws, a0, a1, s0, s1, a_step, s_step):
    candidates = []
    for a in {a0, a1}:
        for s in {s0, s1}:
            key = f"{self._coord._bin_key(a, a_step)}|{self._coord._bin_key(s, s_step)}"
            v = m.get(key)
            if v is not None:
                candidates.append((abs(twa - a) + abs(tws - s), v))
    if not candidates:
        return None
    return round(min(candidates, key=lambda x: x[0])[1], 2)

class PolarPerformanceEntity(_BaseEntity):
    """Current BSP vs Target (%)."""

    _attr_has_entity_name = True
    _attr_name = "Polar Performance"
    _attr_icon = "mdi:percent-outline"
    _attr_native_unit_of_measurement = PERCENTAGE
    _attr_state_class = SensorStateClass.MEASUREMENT

    def _suffix(self) -> str:
        return "polar-perf"

    async def async_added_to_hass(self) -> None:
        await super().async_added_to_hass()
        cfg = self._coord.cfg
        # Update when BSP, TWA, or TWS changes
        self._unsubs = [
            async_track_state_change_event(self.hass, [cfg[CONF_BSP]], self._on_src),
            async_track_state_change_event(self.hass, [cfg[CONF_TWA]], self._on_src),
            async_track_state_change_event(self.hass, [cfg[CONF_TWS]], self._on_src),
        ]

    async def async_will_remove_from_hass(self) -> None:
        for u in getattr(self, "_unsubs", []):
            u()
        self._unsubs = []

    async def _on_src(self, _event) -> None:
        self.async_write_ha_state()

    @property
    def native_value(self):
        bsp = self._state_float(self._coord.cfg[CONF_BSP])
        tgt = self._compute_target_same_as_target_sensor()
        if bsp is None or tgt is None or tgt <= 0:
            return None
        return round(100.0 * bsp / tgt, 1)

    @property
    def extra_state_attributes(self):
        cfg = self._coord.cfg
        bsp = self._state_float(cfg[CONF_BSP])
        tgt = self._compute_target_same_as_target_sensor()
        delta = (None if (bsp is None or tgt is None) else round(bsp - tgt, 2))
        return {
            "boat_speed": None if bsp is None else round(bsp, 2),
            "target_speed": tgt,
            "delta_kn": delta,
            "interpolate": cfg.get(CONF_INTERPOLATE, False),
            "fold_to_180": cfg.get(CONF_FOLD_0_180, True),
        }

    # Reuse the same computation as PolarTargetSpeedEntity to avoid state read races
    def _compute_target_same_as_target_sensor(self):
        cfg = self._coord.cfg
        twa = self._state_float(cfg[CONF_TWA])
        tws = self._state_float(cfg[CONF_TWS])
        if twa is None or tws is None:
            return None
        if cfg.get(CONF_FOLD_0_180, True):
            twa = self._coord._fold_0_180(twa)

        if not (cfg[CONF_TWA_MIN] <= twa <= cfg[CONF_TWA_MAX]) or not (cfg[CONF_TWS_MIN] <= tws <= cfg[CONF_TWS_MAX]):
            return None

        a_step, s_step = cfg[CONF_TWA_STEP], cfg[CONF_TWS_STEP]
        a0 = int(self._coord._bin_floor(twa, a_step, cfg[CONF_TWA_MIN], cfg[CONF_TWA_MAX]))
        s0 = int(self._coord._bin_floor(tws, s_step, cfg[CONF_TWS_MIN], cfg[CONF_TWS_MAX]))
        a1 = min(a0 + a_step, cfg[CONF_TWA_MAX])
        s1 = min(s0 + s_step, cfg[CONF_TWS_MAX])

        m = self._coord.matrix
        # nearest bin
        if not cfg.get(CONF_INTERPOLATE, False) or a1 == a0 or s1 == s0:
            candidates = []
            bk = lambda A,S: f"{self._coord._bin_key(A, a_step)}|{self._coord._bin_key(S, s_step)}"
            for a in {a0, a1}:
                for s in {s0, s1}:
                    v = m.get(bk(a, s))
                    if v is not None:
                        candidates.append((abs(twa - a) + abs(tws - s), v))
            if not candidates:
                return None
            return round(min(candidates, key=lambda x: x[0])[1], 2)

        # bilinear
        bk_a0 = self._coord._bin_key(a0, a_step)
        bk_a1 = self._coord._bin_key(a1, a_step)
        bk_s0 = self._coord._bin_key(s0, s_step)
        bk_s1 = self._coord._bin_key(s1, s_step)
        v00 = m.get(f"{bk_a0}|{bk_s0}")
        v10 = m.get(f"{bk_a1}|{bk_s0}")
        v01 = m.get(f"{bk_a0}|{bk_s1}")
        v11 = m.get(f"{bk_a1}|{bk_s1}")
        if None in (v00, v10, v01, v11):
            # fallback to nearest
            candidates = []
            bk = lambda A,S: f"{self._coord._bin_key(A, a_step)}|{self._coord._bin_key(S, s_step)}"
            for a in {a0, a1}:
                for s in {s0, s1}:
                    v = m.get(bk(a, s))
                    if v is not None:
                        candidates.append((abs(twa - a) + abs(tws - s), v))
            if not candidates:
                return None
            return round(min(candidates, key=lambda x: x[0])[1], 2)

        ax = 0 if a1 == a0 else (twa - a0) / (a1 - a0)
        sx = 0 if s1 == s0 else (tws - s0) / (s1 - s0)
        v0 = v00 * (1 - ax) + v10 * ax
        v1 = v01 * (1 - ax) + v11 * ax
        return round(v0 * (1 - sx) + v1 * sx, 2)
